<html>
  <head>
    <style>
      * {
        box-sizing: border-box;
        position: relative;
        margin: 0px;
      }
    </style>
  </head>
  <body>
    <div class='container'>
      <div id='goog'></div>
      <div id='googl'></div>
      <div id='diff'></div>
      <div id='pctdiff'></div>
      <div id='nytime'></div>
      <canvas id='graph'></canvas>
    </div>
    <script>
      // subscribe to web socket GOOG and GOOGL price updates

      // get handle for web socket - needed to subscribe to stock prices
      const socket = new WebSocket('wss://ws.finnhub.io?token=c6aifiiad3id24fn2m00');

      // get handles for document elements used for stock price updates
      const goog = document.getElementById('goog');
      const googl = document.getElementById('googl');
      const diff = document.getElementById('diff');
      const pctDiff = document.getElementById('pctdiff');
      const nYTime = document.getElementById('nytime');

      // set default values for document elements
      goog.innerText = 'GOOG: No data yet';
      googl.innerText = 'GOOGL: No data yet';
      diff.innerText = 'Difference: No data yet';
      pctDiff.innerText = 'PctDiff: No data yet';
      nYTime.innerText = 'Time in NY: ' + new Date().toLocaleString('en-US', {timeZone: 'America/New_York'});
      
      // declare variables for last stock price of GOOG and GOOGL and set to 0
      let lastGoog = 0;
      let lastGoogl = 0;

      // open an event listener on the web socket and subscribe to GOOG and GOOL stock price updates
      socket.addEventListener('open', (event) => {
        socket.send(JSON.stringify({'type':'subscribe', 'symbol':'GOOG'}));
        socket.send(JSON.stringify({'type':'subscribe', 'symbol':'GOOGL'}));
      });

      // handle stock price update messages from the web socket.
      socket.addEventListener('message', (event) => {
        const parsedObj = JSON.parse(event.data);
        if (parsedObj.data) {
          for (const obj of parsedObj.data) {
            if (obj.s === 'GOOG') {
              goog.innerText = 'GOOG: ' + (obj.p).toFixed(2);
              lastGoog = obj.p;
            }
            if (obj.s === 'GOOGL') {
              googl.innerText = 'GOOGL: ' + (obj.p).toFixed(2);
              lastGoogl = obj.p;
            }
            diff.innerText = lastGoog === 0 ? 'N/A' : 'Difference: ' + (lastGoog - lastGoogl).toFixed(2);
            pctDiff.innerText = lastGoog === 0 ? 'N/A' : 'PctDiff: ' + (100 * (lastGoog - lastGoogl) / lastGoog).toFixed(2) + '%';
            nYTime.innerText = 'Time in NY: ' + new Date(obj.t).toLocaleString('en-US', {timeZone: 'America/New_York'});
          }
        } else {
          console.log('non-data object: ' + event.data);
        }
      });

      // helper function to unsubscribe if needed
      const unsubscribe = (symbol) => {
        socket.send(JSON.stringify({'type':'unsubscribe', 'symbol': symbol}));
      }

      // get GOOG and GOOGL candle data

      // get current date and time
      const now = Math.floor(Date.now() / 1000);

      // define data set
      const candleBaseUrl = 'https://finnhub.io/api/v1/stock/candle?symbol=';
      const secondsPerWeek = 7 * 24 * 60 * 60;
      const aWeekAgo = now - secondsPerWeek;
      const resolution = '5';
      const resolutionInSeconds = parseInt(resolution) * 60;
      const symbols = ['GOOG', 'GOOGL'];

      // empty array for results
      const results = {};
      const graphData = [];

      // get the data
      for (const symbol of symbols) {
        fetch(candleBaseUrl + symbol + '&resolution=' + resolution + '&from=' + aWeekAgo + '&to=' + now + '&token=c6aifiiad3id24fn2m00')
        .then((response) => {
          return response.json();
        })
        .then((obj) => {
          // load the results array
          console.log(obj);
          results[symbol] = {};
          for (let index = 0; index < obj.t.length; index++) {
            results[symbol][obj.t[index]] = {};
            results[symbol][obj.t[index]].low = obj.l[index];
            results[symbol][obj.t[index]].high = obj.h[index];
            results[symbol][obj.t[index]].open = obj.o[index];
            results[symbol][obj.t[index]].close = obj.c[index];
            results[symbol][obj.t[index]].date = obj.t[index];
          }
          if (symbols[0] in results && symbols[1] in results) {
            processData();
          }
        })
        .catch((error) => {
          console.error('Error fetching data: ', error);
        });
      }

      let earliestDate = now;
      let latestDate = now;
      let maxY = 0;
      let minY = 0;

      const processData = () => {
        for (const date in results[symbols[0]]) {
          if ( !(date in results[symbols[1]]) ) {
            delete results[symbols[0]][date];
          }
        }
        for (const date in results[symbols[1]]) {
          if ( !(date in results[symbols[0]]) ) {
            delete results[symbols[1]][date];
          } else {
            earliestDate = date < earliestDate ? date : earliestDate;
            latestDate = date > latestDate ? date : latestDate;
          }
        }
        for (const date in results[symbols[0]]) {
          // graphData[date - earliestDate] = {};
          // graphData[date - earliestDate].maxDiff = results[symbols[0]][date].high - results[symbols[1]][date].low;
          // graphData[date - earliestDate].minDiff = results[symbols[0]][date].low - results[symbols[1]][date].high;
          const dataObj = {};
          dataObj[date] = {};
          let maxDiff = results[symbols[0]][date].high - results[symbols[1]][date].low;
          let minDiff = results[symbols[0]][date].low - results[symbols[1]][date].high;
          maxY = maxDiff > maxY ? maxDiff : maxY;
          minY = minDiff < minY ? minDiff : minY;
          dataObj[date].maxDiff = maxDiff;
          dataObj[date].minDiff = minDiff;
          graphData.push(dataObj);
        }
        graphData.sort();
        drawGraph();
      }
      
      const graph = document.getElementById('graph');
      graph.width = 500;
      graph.height = 500;
      const ctxGraph = graph.getContext('2d');

      const pixelsPerDiv = 400 / 60;

      let x = 50 + pixelsPerDiv;
      const drawGraph = () => {
        // console.log(results);
        console.log(graphData);
        ctxGraph.beginPath();
        ctxGraph.moveTo(50, 450);
        ctxGraph.lineTo(50, 50);
        ctxGraph.moveTo(50, 450);
        ctxGraph.lineTo(450, 450);
        ctxGraph.stroke();

        const yPxPerDollar = 400 / maxY;
        ctxGraph.strokeStyle = 'blue';
        for (let index = graphData.length - 60; index < graphData.length; index++) {
          const date = Object.keys(graphData[index])[0];
          const yLow = 450 - graphData[index][date].minDiff * yPxPerDollar;
          const yHigh = 450 - graphData[index][date].maxDiff * yPxPerDollar;
          ctxGraph.beginPath();
          ctxGraph.moveTo(x, yLow);
          ctxGraph.lineTo(x, yHigh);
          ctxGraph.stroke();
          x += pixelsPerDiv;
        }
      }
    </script>
  </body>
</html>
