<html>
  <head>
    <style>
      html {
        box-sizing: border-box;
      }
      
      *,
      *:before,
      *:after {
        box-sizing: inherit;
      }
      
      body {
        font-family: "Roboto", "Helvetica", "Arial", Sans-Serif;
        background-color: #f6f6f6;
        font-size: 16px;
        margin: 0;
      }
      
      .container {
        display: flex;
        flex-flow: row wrap;
        text-align: center;
      }

      .container > #diff, .container > #nytime {
        flex: 1 100%;
      }

      .ticker, .price {
        flex: 1 50%;
      }

      .ticker {
        font-size: 6vh;
        height: 10vh;
        padding: 3vh 0 0;
      }

      .price {
        font-size: 5vh;
        height: 6vh;
      }

      #diff {
        font-size: 4vh;
      }

      #nytime {
        font-size: 3vh;
      }

      @media screen and (max-aspect-ratio: 1/1) {
        .ticker { font-size: 4vh; height: 6vh; padding: 2vh 0 0;}
        .price { font-size: 3vh; height: 4vh; }
        #diff { font-size: 2.5vh; }
        #nytime { font-size: 2vh; }
      }
    </style>
  </head>
  <body>
    <div class='container'>
      <div class='ticker'>GOOG</div>
      <div class='ticker'>GOOGL</div>
      <div class='price' id='goog'></div>
      <div class='price' id='googl'></div>
      <div id='diff'></div>
      <div id='nytime'></div>
      <canvas id='graph'></canvas>
    </div>
    <script>
      const arb = () => {
        // two symbols to compare - program written specifically to compare GOOG and GOOGL
        const symbols = ['GOOG', 'GOOGL'];

        // declare array for last price of each stock, initialized at 0
        const lastValue = [0, 0];
  
        // declare object to contain results for fetched data
        let results = {};
    
        // get handles for document elements used for stock price updates
        const goog = document.getElementById('goog');
        const googl = document.getElementById('googl');
        const diff = document.getElementById('diff');
        const nYTime = document.getElementById('nytime');
    
        // Subscribe to web socket for real-time stock data
        // parameter is array of stock symbols, capitalized
        const ws = () => {
          // get handle for web socket - needed to subscribe to stock prices
          const socket = new WebSocket('wss://ws.finnhub.io?token=c6aifiiad3id24fn2m00');

          // set default values for document elements
          goog.innerText = 'No data yet';
          googl.innerText = 'No data yet';
          diff.innerText = 'Diff: No data yet';
          nYTime.innerText = `Time in NY: ${new Date().toLocaleString('en-US', {timeZone: 'America/New_York'})}`;
          
          // open an event listener on the web socket and subscribe to stock price updates
          socket.addEventListener('open', (event) => {
            socket.send(JSON.stringify({'type':'subscribe', 'symbol':symbols[0]}));
            socket.send(JSON.stringify({'type':'subscribe', 'symbol':symbols[1]}));
          });
    
          let minutes;

          // handle stock price update messages from the web socket.
          socket.addEventListener('message', (event) => {
            const parsedObj = JSON.parse(event.data);
            if (parsedObj.data) {
              let nowMinutes = new Date().getMinutes();
              for (const obj of parsedObj.data) {
                if (obj.s === symbols[0]) {
                  goog.innerText = '' + (obj.p).toFixed(2);
                  lastValue[0] = obj.p;
                }
                if (obj.s === symbols[1]) {
                  googl.innerText = '' + (obj.p).toFixed(2);
                  lastValue[1] = obj.p;
                }
                diff.innerText = lastValue[0] === 0 ? 'N/A' :
                  `Diff: ${(lastValue[0] - lastValue[1]).toFixed(2)} (${(100 * (lastValue[0] - lastValue[1]) / lastValue[0]).toFixed(2)} %)`;
                nYTime.innerText = `NYC Time: ${new Date(obj.t).toLocaleString('en-US', {timeZone: 'America/New_York'})}`;
                drawPoint();
              }
              if (minutes && (minutes < nowMinutes || minutes - nowMinutes === 59)) {
                results = {};
                fetchCandles();
              }
              minutes = nowMinutes;
            } else {
              console.log('non-data object: ' + event.data);
            }
          });
    
          // helper function to unsubscribe if needed
          const unsubscribe = (symbol) => {
            socket.send(JSON.stringify({'type':'unsubscribe', 'symbol': symbol}));
          }
        }
  
        // fetch candle data for symbols
        const fetchCandles = () => {
          // get current date and time
          const now = Math.floor(Date.now() / 1000);
    
          // define data set
          const candleBaseUrl = 'https://finnhub.io/api/v1/stock/candle?symbol=';
          const secondsPerWeek = 7 * 24 * 60 * 60;
          const aWeekAgo = now - secondsPerWeek;
          const secondsPer30Days = 30 * 24 * 60 * 60;
          const thirtyDaysAgo = now - secondsPer30Days;
          const secondsPerYear = 365 * 24 * 60 * 60;
          const aYearAgo = now - secondsPerYear;
    
          // fetch the data from finnhub
          for (const symbol of symbols) {
            results[symbol] = {};
            // from date is a year ago, resolution is months
            let from = now - 365 * 24 * 60 * 60;
            let resolution = 'M';

            fetch(candleBaseUrl + symbol + '&resolution=' + resolution + '&from=' + from + '&to=' + now + '&token=c6aifiiad3id24fn2m00')
            .then((response) => {
              return response.json();
            })
            .then((obj) => {
              // load the results array
              // console.log(obj);
              results[symbol][resolution] = obj;
            })
            .then(() => {
              // from date is 30 days ago, resolution is days
              from = now - 30 * 24 * 60 * 60;
              resolution = 'D';
              fetch(candleBaseUrl + symbol + '&resolution=' + resolution + '&from=' + from + '&to=' + now + '&token=c6aifiiad3id24fn2m00')
                .then((response) => {
                return response.json();
              })
              .then((obj) => {
                // load the results array
                // console.log(obj);
                results[symbol][resolution] = obj;
              })
              .then(() => {
                // from date last timestamp in 'D' data, resolution is minutes
                from = results[symbol][resolution].t.slice(-1);
                resolution = '1';
                fetch(candleBaseUrl + symbol + '&resolution=' + resolution + '&from=' + from + '&to=' + now + '&token=c6aifiiad3id24fn2m00')
                  .then((response) => {
                  return response.json();
                })
                .then((obj) => {
                  // load the results array
                  // console.log(obj);
                  results[symbol][resolution] = obj;
                  if (results[symbols[0]].M && results[symbols[1]].M &&
                      results[symbols[0]].D && results[symbols[1]].D &&
                      results[symbols[0]]['1'] && results[symbols[1]]['1']) {
                    processData();
                  }
                })
                .catch((error) => {
                  console.error('Error fetching data: ', error);
                });
              })
              .catch((error) => {
                console.error('Error fetching data: ', error);
              });
            })
            .catch((error) => {
              console.error('Error fetching data: ', error);
            });
          }
        }

        // Eliminate data elements from symbolA 1 minute data that are not included
        // in symbolB data, and are outside of normal exchange hours.
        // This only works in the Pacific time zone because of the hours and
        // minutes specified in the culling filter.
        const cullSpurious = (symbolA, symbolB) => {
          for (let index = results[symbolA]['1'].t.length - 1; index > -1; index--) {
            const dateInSeconds = results[symbolA]['1'].t[index];
            const date = new Date(dateInSeconds * 1000);
            // culling filter
            if ((date.getHours() < 7 && date.getMinutes() < 31) ||
              date.getHours() < 6 ||
              (date.getHours() > 12 && date.getMinutes() > 0) ||
              !results[symbolB]['1'].t.includes(dateInSeconds) || 
              date.getDay() === 0 ||
              date.getDay() === 6) {
              for (elem in results[symbolA]['1']) {
                if (typeof(results[symbolA]['1'][elem]) === 'object') {
                  results[symbolA]['1'][elem].splice(index, 1);
                }
              }
            }
          }
        }

        // Returns an array of indices in last day of <results> spaced <minutes> apart
        const idxEngine = (minutes) => {
          // const firstMinute = results[symbols[0]].t[0];
          const date = new Date(results[symbols[0]]['1'].t[0] * 1000);
          const monthDayOffset = results[symbols[0]].M.t.length + results[symbols[0]].D.t.length;
          const idxArray = [monthDayOffset];

          let prevHour = date.getHours();
          let prevMin = minutes * Math.floor(date.getMinutes() / minutes);
          let incr = 1;
          for (let idx = 0; idx < results[symbols[0]]['1'].t.length; idx++) {
            const nextDate = new Date(results[symbols[0]]['1'].t[idx] * 1000);
            let nextHour = nextDate.getHours();
            let nextMin = nextDate.getMinutes();
            if (minutes <= 60 && prevHour != nextHour && nextHour !== 13) { // time zone dependent (hour 13)
              idxArray.push(monthDayOffset + idx + 1); // add 1 to include time until top of hour in data
              prevHour = nextHour;
              prevMin = minutes * Math.floor(nextMin / minutes);
            } else if (nextMin - prevMin > minutes) {
              idxArray.push(monthDayOffset + idx);
              prevMin = minutes * Math.floor(nextMin / minutes);
            }
          }
          return idxArray;
        }

        // get rid of extra data (partial month and day) at end of month and day arrays in results
        const popLastMonthDay = () => {
          for (symbol of symbols) {
            for (per of ['M', 'D']) {
              for (ary in results[symbol][per]) {
                if (typeof(results[symbol][per][ary]) === 'object') {
                  results[symbol][per][ary].pop();
                }
              }
            }
          }
        }

        // Performs multiple processing steps to filter and prep the results data for graphing
        const processData = () => {
          // console.log(results.GOOG.c.slice(-10));
          // console.log(results.GOOG.v.slice(-10));
          // console.log(results.GOOGL.c.slice(-10));
          // console.log(results.GOOGL.v.slice(-10));
  
          // get initial values for prices and differences or handle off hours
          handleAfterHours();

          // Eliminate spurious data
          cullSpurious(symbols[0], symbols[1]);
          cullSpurious(symbols[1], symbols[0]);
  
          // console.log(results);

          popLastMonthDay();
  
          // Declare and load arrays for indices of first occurrance of day/hour in results
          // const dayIndices = idxEngine(24 * 60);
          const qHourIndices = idxEngine(15);

          // // get last month and last day index
          // const lastMonthIndex = results[symbols[0]].M.t.length;
          // const lastDayIndex = results[symbols[0]].M.t.length;

          for (symbol of symbols) {
            results.timeStamps = results[symbol].M.t.concat(results[symbol].D.t).concat(results[symbol]['1'].t);
            results[symbol].highs = results[symbol].M.h.concat(results[symbol].D.h).concat(results[symbol]['1'].h);
            results[symbol].lows = results[symbol].M.l.concat(results[symbol].D.l).concat(results[symbol]['1'].l);
            results[symbol].opens = results[symbol].M.o.concat(results[symbol].D.o).concat(results[symbol]['1'].o);
            results[symbol].closes = results[symbol].M.c.concat(results[symbol].D.c).concat(results[symbol]['1'].c);
          }
  
          // get diff data for each data point
          results.highDiff = results[symbols[0]].highs.map((n, i) =>
            n - results[symbols[1]].highs[i] > results[symbols[0]].lows[i] - results[symbols[1]].lows[i] ?
            n - results[symbols[1]].highs[i] : results[symbols[0]].lows[i] - results[symbols[1]].lows[i]
          );
          results.lowDiff = results[symbols[0]].lows.map((n, i) =>
            n - results[symbols[1]].lows[i] < results[symbols[0]].highs[i] - results[symbols[1]].highs[i] ?
            n - results[symbols[1]].lows[i] : results[symbols[0]].highs[i] - results[symbols[1]].highs[i]
          );
          results.openDiff = results[symbols[0]].opens.map((n, i) => n - results[symbols[1]].opens[i]);  // subract low GOOG from low GOOGL
          results.closeDiff = results[symbols[0]].closes.map((n, i) => n - results[symbols[1]].closes[i]);  // subract low GOOG from low GOOGL

          results.maxY = 0;
          results.minY = 0;
  
          // load months data
          let startIndex = 1;
          let endIndex = results[symbols[0]].M.t.length;
          loadData('months', startIndex, endIndex);

          // load days data
          startIndex = endIndex;
          endIndex = startIndex + results[symbols[0]].D.t.length;
          loadData('days', startIndex, endIndex);

          // load qHours data
          results.qHours = {};
          for (name of ['timeStamps', 'lowDiff', 'highDiff', 'openDiff', 'closeDiff']) {
            results.qHours[name] = [];
          }
          for (let idx = 0; idx < qHourIndices.length; idx++) {
            results.qHours.timeStamps.push(results.timeStamps[qHourIndices[idx]]);
            const highY = Math.max(...results.highDiff.slice(qHourIndices[idx], qHourIndices[idx + 1]));
            const lowY = Math.min(...results.lowDiff.slice(qHourIndices[idx], qHourIndices[idx + 1]));
            const openY = results.openDiff[qHourIndices[idx]];
            // closeIndex calc is to make sure the close is captured for the last minute of data
            const closeIndex =
              qHourIndices[idx] === results.timeStamps.length - 1 ?
              qHourIndices[idx] : qHourIndices[idx + 1] - 1;
            const closeY = results.closeDiff[closeIndex];
            results.qHours.highDiff.push(highY);
            results.qHours.lowDiff.push(lowY);
            results.qHours.openDiff.push(openY);
            results.qHours.closeDiff.push(closeY);
            results.maxY = highY > results.maxY ? highY : results.maxY;
            results.minY = lowY < results.minY ? lowY : results.minY;
          }

          // load minutes data
          const resultsLength = results.timeStamps.length;
          startIndex = resultsLength - 15;
          startIndex = startIndex > endIndex ? startIndex : endIndex;
          endIndex = results.timeStamps.length;
          loadData('minutes', startIndex, endIndex);

          console.log(results);
          drawGraph();
          console.log('done');
        }

        const loadData = (dataName, startIndex, endIndex) => {
          results[dataName] = {};
          results[dataName].timeStamps = results.timeStamps.slice(startIndex, endIndex);
          for (name of ['lowDiff', 'highDiff', 'openDiff', 'closeDiff']) {
            results[dataName][name] = results[name].slice(startIndex, endIndex);
            const highY = Math.max(...results[dataName][name]);
            const lowY = Math.min(...results[dataName][name]);
            results.maxY = highY > results.maxY ? highY : results.maxY;
            results.minY = lowY < results.minY ? lowY : results.minY;
          }
        }

        window.onresize = () => {
          graph.width = window.innerWidth;
          graph.height = window.innerHeight < window.innerWidth ?
            0.75 * window.innerHeight : 0.84 * window.innerHeight;
          leftMargin = 0.08 * graph.width;
          topMargin = 0.04 * graph.height;
          plotWidth = graph.width - 1.25 * leftMargin;
          plotHeight = graph.height - 1.5 * topMargin;
          drawGraph();
        }
        
        // get the graph canvas and initialize its size
        const graph = document.getElementById('graph');
        graph.width = window.innerWidth;
        graph.height = window.innerHeight < window.innerWidth ?
          0.75 * window.innerHeight : 0.84 * window.innerHeight;
        const ctxGraph = graph.getContext('2d');
        const gParams = {};

        let leftMargin = 0.08 * graph.width;
        let topMargin = 0.04 * graph.height;
        let plotWidth = graph.width - 1.25 * leftMargin;
        let plotHeight = graph.height - 1.5 * topMargin;

        const drawGraph = () => {
          let plotDataLength = 0;
          for (name of ['months', 'days', 'qHours', 'minutes']) {
            plotDataLength += results[name].timeStamps.length;
          }
          ctxGraph.clearRect(0, 0, graph.width, graph.height);
          const xPixelsPerDiv = plotWidth / (plotDataLength + 1);
          let x = leftMargin + xPixelsPerDiv / 2;
          gParams.xPixelsPerDiv = xPixelsPerDiv;
          gParams.dataLength = plotDataLength;
    
          const graphMinY = 10 * Math.floor(results.minY / 10);
          const graphMaxY = 10 * Math.ceil(results.maxY / 10);
          const graphRange = graphMaxY - graphMinY;
          gParams.graphRange = graphRange;
          const graphZeroRatio = graphMinY < 0 ? graphMaxY / graphRange : 1;
          const yPxPerDollar = plotHeight / graphRange;
          gParams.graphZeroRatio = graphZeroRatio;
          gParams.yPxPerDollar = yPxPerDollar;
  
          // Draw shading
          const monthsWidth = results.months.timeStamps.length * xPixelsPerDiv;
          const daysWidth = results.days.timeStamps.length * xPixelsPerDiv;
          const qHoursWidth = results.qHours.timeStamps.length * xPixelsPerDiv;
          const minutesWidth = results.minutes.timeStamps.length * xPixelsPerDiv;
          ctxGraph.fillStyle = 'rgba(0,0,0,0.4)';
          ctxGraph.fillRect(leftMargin, topMargin, monthsWidth, plotHeight);
          ctxGraph.fillStyle = 'rgba(0,0,0,0.3)';
          ctxGraph.fillRect(leftMargin + monthsWidth, topMargin, daysWidth, plotHeight);
          ctxGraph.fillStyle = 'rgba(0,0,0,0.2)';
          ctxGraph.fillRect(leftMargin + monthsWidth + daysWidth, topMargin, qHoursWidth, plotHeight);
          ctxGraph.fillStyle = 'rgba(0,0,0,0.1)';
          ctxGraph.fillRect(leftMargin + monthsWidth + daysWidth + qHoursWidth, topMargin,
            minutesWidth + xPixelsPerDiv, plotHeight);
  
          // Draw axes and tick marks
          ctxGraph.fillStyle = 'black';
          ctxGraph.strokeStyle = 'black';
          ctxGraph.lineCap = 'square';
          ctxGraph.lineWidth = 1;
          ctxGraph.beginPath();
          ctxGraph.moveTo(leftMargin, topMargin + plotHeight);
          ctxGraph.lineTo(leftMargin, topMargin);
          ctxGraph.moveTo(leftMargin, topMargin + plotHeight * graphZeroRatio);
          ctxGraph.lineTo(leftMargin + plotWidth, topMargin + plotHeight * graphZeroRatio);
          ctxGraph.stroke();
          const ticks = graphMaxY - graphMinY + 1;
          for (let tick = 0; tick < ticks; tick++) {
            if (tick % 10 === 0) {
              ctxGraph.moveTo(0.9 * leftMargin, topMargin + tick * yPxPerDollar);
              ctxGraph.lineTo(leftMargin, topMargin + tick * yPxPerDollar);
              ctxGraph.stroke();
              ctxGraph.textBaseline = 'middle';
              ctxGraph.textAlign = 'right';
              const fontHeight = plotWidth > plotHeight ? 0.05 * plotHeight : 0.05 * plotWidth;
              ctxGraph.font = '' + fontHeight + 'px sans-serif';
              ctxGraph.fillText('' + graphMaxY - tick, 0.8 * leftMargin, topMargin + tick * yPxPerDollar);
            }
          }

          // Draw data values
          for (period of ['months', 'days', 'qHours', 'minutes']) {
            const graphSub = results[period];
            for (let index = 0; index < graphSub.timeStamps.length; index++) {
              const yLow = topMargin + (graphZeroRatio * graphRange - graphSub.lowDiff[index]) * yPxPerDollar;
              const yHigh = topMargin + (graphZeroRatio * graphRange - graphSub.highDiff[index]) * yPxPerDollar;
              const yOpen = topMargin + (graphZeroRatio * graphRange - graphSub.openDiff[index]) * yPxPerDollar;
              const yClose = topMargin + (graphZeroRatio * graphRange - graphSub.closeDiff[index]) * yPxPerDollar;
              ctxGraph.strokeStyle = yOpen >= yClose ? 'green' : 'red';
              ctxGraph.lineWidth = graph.width * 2 / graph.height;
              ctxGraph.beginPath();
              ctxGraph.moveTo(x, yLow);
              ctxGraph.lineTo(x, yHigh);
              ctxGraph.stroke();
              ctxGraph.lineWidth = graph.width * 6 / graph.height;
              ctxGraph.beginPath();
              ctxGraph.moveTo(x, yOpen);
              ctxGraph.lineTo(x, yClose);
              ctxGraph.stroke();
              x += xPixelsPerDiv;
            }
          }
        }

        // Draws a point on the graph when the web socket gets a new value
        const drawPoint = () => {
          const instDiff = lastValue[0] !== 0 && lastValue[1] !== 0 ? lastValue[0] - lastValue[1] : null;
          if (instDiff) {
            ctxGraph.fillStyle = 'rgba(255,255,0,.2)';
            ctxGraph.beginPath();
            ctxGraph.arc(
              leftMargin + gParams.xPixelsPerDiv * (0.5 + gParams.dataLength),
              topMargin + (gParams.graphZeroRatio * gParams.graphRange - instDiff) * gParams.yPxPerDollar,
              3, 0, 2 * Math.PI
            );
            ctxGraph.fill();
          }
        }

        const handleAfterHours = () => {
          if (lastValue[0] === 0 && lastValue[1] === 0) {
            const googPrice = results[symbols[0]]['1'].c.at(-1);
            const googlPrice = results[symbols[1]]['1'].c.at(-1);
            goog.innerText = '' + (googPrice).toFixed(2);
            googl.innerText = '' + (googlPrice).toFixed(2);
            diff.innerText = `Diff: ${(googPrice - googlPrice).toFixed(2)} (${(100 * (googPrice - googlPrice) / googPrice).toFixed(2)} %)`;
          }
        }

        ws();
        fetchCandles();
      }
      arb();
    </script>
  </body>
</html>
