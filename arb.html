<html>
  <head>
    <style>
      * {
        box-sizing: border-box;
        position: relative;
        margin: 0px;
      }
    </style>
  </head>
  <body>
    <div class='container'>
      <div id='goog'></div>
      <div id='googl'></div>
      <div id='diff'></div>
      <div id='pctdiff'></div>
      <div id='nytime'></div>
      <canvas id='graph'></canvas>
    </div>
    <script>
      // subscribe to web socket GOOG and GOOGL price updates

      // get handle for web socket - needed to subscribe to stock prices
      const socket = new WebSocket('wss://ws.finnhub.io?token=c6aifiiad3id24fn2m00');

      // get handles for document elements used for stock price updates
      const goog = document.getElementById('goog');
      const googl = document.getElementById('googl');
      const diff = document.getElementById('diff');
      const pctDiff = document.getElementById('pctdiff');
      const nYTime = document.getElementById('nytime');

      // set default values for document elements
      goog.innerText = 'GOOG: No data yet';
      googl.innerText = 'GOOGL: No data yet';
      diff.innerText = 'Difference: No data yet';
      pctDiff.innerText = 'PctDiff: No data yet';
      nYTime.innerText = 'Time in NY: ' + new Date().toLocaleString('en-US', {timeZone: 'America/New_York'});
      
      // declare variables for last stock price of GOOG and GOOGL and set to 0
      let lastGoog = 0;
      let lastGoogl = 0;

      // open an event listener on the web socket and subscribe to GOOG and GOOL stock price updates
      socket.addEventListener('open', (event) => {
        socket.send(JSON.stringify({'type':'subscribe', 'symbol':'GOOG'}));
        socket.send(JSON.stringify({'type':'subscribe', 'symbol':'GOOGL'}));
      });

      // handle stock price update messages from the web socket.
      socket.addEventListener('message', (event) => {
        const parsedObj = JSON.parse(event.data);
        if (parsedObj.data) {
          for (const obj of parsedObj.data) {
            if (obj.s === 'GOOG') {
              goog.innerText = 'GOOG: ' + (obj.p).toFixed(2);
              lastGoog = obj.p;
            }
            if (obj.s === 'GOOGL') {
              googl.innerText = 'GOOGL: ' + (obj.p).toFixed(2);
              lastGoogl = obj.p;
            }
            diff.innerText = lastGoog === 0 ? 'N/A' : 'Difference: ' + (lastGoog - lastGoogl).toFixed(2);
            pctDiff.innerText = lastGoog === 0 ? 'N/A' : 'PctDiff: ' + (100 * (lastGoog - lastGoogl) / lastGoog).toFixed(2) + '%';
            nYTime.innerText = 'Time in NY: ' + new Date(obj.t).toLocaleString('en-US', {timeZone: 'America/New_York'});
          }
        } else {
          console.log('non-data object: ' + event.data);
        }
      });

      // helper function to unsubscribe if needed
      const unsubscribe = (symbol) => {
        socket.send(JSON.stringify({'type':'unsubscribe', 'symbol': symbol}));
      }

      // get GOOG and GOOGL candle data

      // get current date and time
      const now = Math.floor(Date.now() / 1000);

      // define data set
      const candleBaseUrl = 'https://finnhub.io/api/v1/stock/candle?symbol=';
      const secondsPerWeek = 7 * 24 * 60 * 60;
      const aWeekAgo = now - secondsPerWeek;

      // allowable resolutions: 1, 5, 15, 30, 60, D, W, M - all strings, numbers represent minutes
      const resolution = '1';

      // two symbols to compare - program written specifically to compare GOOG and GOOGL
      const symbols = ['GOOG', 'GOOGL'];

      // empty array for results
      const results = {};

      // get the data
      for (const symbol of symbols) {
        fetch(candleBaseUrl + symbol + '&resolution=' + resolution + '&from=' + aWeekAgo + '&to=' + now + '&token=c6aifiiad3id24fn2m00')
        .then((response) => {
          return response.json();
        })
        .then((obj) => {
          // load the results array
          // console.log(obj);
          results[symbol] = obj;
          if (symbols[0] in results && symbols[1] in results) {
            // console.log(results);
            processData();
          }
        })
        .catch((error) => {
          console.error('Error fetching data: ', error);
        });
      }

      let earliestDate = now;
      let latestDate = now;

      const processData = () => {
        // eliminate datapoints that do not contain both GOOG and GOOGL data
        for (let index = results[symbols[0]].t.length - 1; index > -1; index--) {
          if (!results[symbols[1]].t.includes(results[symbols[0]].t[index])) {
            for (elem in results[symbols[0]]) {
              if (typeof(results[symbols[0]][elem]) === 'object') {
                results[symbols[0]][elem].splice(index, 1);
              }
            }
          }
        }
        for (let index = results[symbols[1]].t.length - 1; index > -1; index--) {
          if (!results[symbols[0]].t.includes(results[symbols[1]].t[index])) {
            for (elem in results[symbols[1]]) {
              if (typeof(results[symbols[1]][elem]) === 'object') {
                results[symbols[1]][elem].splice(index, 1);
              }
            }
          }
        }
        // console.log(results);

        // reduce data to only the datapoints of interest
        for (const symbol of symbols) {
          for (elem in results[symbol]) {
            if (typeof(results[symbol][elem]) === 'object') {
              results[symbol][elem].splice(0, results[symbol][elem].length - 60);
            }
          }
        }
        console.log(results);
        drawGraph();
      }
      
      const graph = document.getElementById('graph');
      graph.width = 500;
      graph.height = 500;
      const ctxGraph = graph.getContext('2d');

      const pixelsPerDiv = 400 / 60;
      const graphData = {};

      let x = 50 + pixelsPerDiv;
      const drawGraph = () => {
        let maxY = 0;
        let minY = 0;

        graphData.timeStamp = [];
        graphData.avgRange = [];
        graphData.avgDiff = [];
        graphData.lowDiff = [];
        graphData.highDiff = [];
        for (let index = 0; index < results[symbols[0]].t.length; index++) {
          const range = [];
          range[symbols[0]] = results[symbols[0]].h[index] - results[symbols[0]].l[index];
          range[symbols[1]] = results[symbols[1]].h[index] - results[symbols[1]].l[index];

          graphData.timeStamp[index] = results[symbols[0]].t[index];
          graphData.avgRange[index] = (range[symbols[0]] + range[symbols[1]]) / 2;
          graphData.avgDiff[index] = (
            results[symbols[0]].h[index] - results[symbols[1]].h[index] +
            results[symbols[0]].l[index] - results[symbols[1]].l[index]
          ) / 2;
          const highY = graphData.avgDiff[index] + graphData.avgRange[index] / 2;
          const lowY = graphData.avgDiff[index] - graphData.avgRange[index] / 2
          graphData.lowDiff[index] = lowY;
          graphData.highDiff[index] = highY;
          maxY = highY > maxY ? highY : maxY;
          minY = lowY < minY ? lowY : minY;
        }

        const graphMinY = Math.floor(minY);
        const graphMaxY = Math.ceil(maxY);
        const graphRange = graphMaxY - graphMinY;
        const graphZeroRatio = graphMinY < 0 ? graphMaxY / graphRange : 1;
        const yPxPerDollar = 400 / graphRange;

        console.log(graphData);
        ctxGraph.beginPath();
        ctxGraph.moveTo(50, 450);
        ctxGraph.lineTo(50, 50);
        ctxGraph.moveTo(50, 450);
        ctxGraph.lineTo(450, 450);
        ctxGraph.stroke();
        const ticks = graphMaxY - graphMinY + 1;
        for (let tick = 0; tick < ticks; tick++) {
          ctxGraph.moveTo(45, 50 + tick * yPxPerDollar);
          ctxGraph.lineTo(50, 50 + tick * yPxPerDollar);
          ctxGraph.stroke();
          ctxGraph.textBaseline = 'middle';
          ctxGraph.textAlign = 'right';
          ctxGraph.font = '15px sans-serif';
          ctxGraph.fillText('' + graphMaxY - tick, 40, 50 + tick * yPxPerDollar);
        }

        ctxGraph.strokeStyle = 'blue';
        for (let index = 0; index < graphData.timeStamp.length; index++) {
          const yLow = 50 + (graphZeroRatio * graphRange - graphData.lowDiff[index]) * yPxPerDollar ;
          const yHigh = 50 + (graphZeroRatio * graphRange - graphData.highDiff[index]) * yPxPerDollar ;
          ctxGraph.beginPath();
          ctxGraph.moveTo(x, yLow);
          ctxGraph.lineTo(x, yHigh);
          ctxGraph.stroke();
          x += pixelsPerDiv;
        }
      }
    </script>
  </body>
</html>
