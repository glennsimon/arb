<html>
  <head>
    <style>
      * {
        box-sizing: border-box;
        position: relative;
        margin: 0px;
      }
    </style>
  </head>
  <body>
    <div class='container'>
      <div id='goog'></div>
      <div id='googl'></div>
      <div id='diff'></div>
      <div id='pctdiff'></div>
      <div id='nytime'></div>
      <canvas id='graph'></canvas>
    </div>
    <script>
      // subscribe to web socket GOOG and GOOGL price updates

      // get handle for web socket - needed to subscribe to stock prices
      const socket = new WebSocket('wss://ws.finnhub.io?token=c6aifiiad3id24fn2m00');

      // get handles for document elements used for stock price updates
      const goog = document.getElementById('goog');
      const googl = document.getElementById('googl');
      const diff = document.getElementById('diff');
      const pctDiff = document.getElementById('pctdiff');
      const nYTime = document.getElementById('nytime');

      // set default values for document elements
      goog.innerText = 'GOOG: No data yet';
      googl.innerText = 'GOOGL: No data yet';
      diff.innerText = 'Difference: No data yet';
      pctDiff.innerText = 'PctDiff: No data yet';
      nYTime.innerText = 'Time in NY: ' + new Date().toLocaleString('en-US', {timeZone: 'America/New_York'});
      
      // declare variables for last stock price of GOOG and GOOGL and set to 0
      let lastGoog = 0;
      let lastGoogl = 0;

      // open an event listener on the web socket and subscribe to GOOG and GOOL stock price updates
      socket.addEventListener('open', (event) => {
        socket.send(JSON.stringify({'type':'subscribe', 'symbol':'GOOG'}));
        socket.send(JSON.stringify({'type':'subscribe', 'symbol':'GOOGL'}));
      });

      // handle stock price update messages from the web socket.
      socket.addEventListener('message', (event) => {
        const parsedObj = JSON.parse(event.data);
        if (parsedObj.data) {
          for (const obj of parsedObj.data) {
            if (obj.s === 'GOOG') {
              goog.innerText = 'GOOG: ' + (obj.p).toFixed(2);
              lastGoog = obj.p;
            }
            if (obj.s === 'GOOGL') {
              googl.innerText = 'GOOGL: ' + (obj.p).toFixed(2);
              lastGoogl = obj.p;
            }
            diff.innerText = lastGoog === 0 ? 'N/A' : 'Difference: ' + (lastGoog - lastGoogl).toFixed(2);
            pctDiff.innerText = lastGoog === 0 ? 'N/A' : 'PctDiff: ' + (100 * (lastGoog - lastGoogl) / lastGoog).toFixed(2) + '%';
            nYTime.innerText = 'Time in NY: ' + new Date(obj.t).toLocaleString('en-US', {timeZone: 'America/New_York'});
          }
        } else {
          console.log('non-data object: ' + event.data);
        }
      });

      // helper function to unsubscribe if needed
      const unsubscribe = (symbol) => {
        socket.send(JSON.stringify({'type':'unsubscribe', 'symbol': symbol}));
      }

      // get GOOG and GOOGL candle data

      // get current date and time
      const now = Math.floor(Date.now() / 1000);

      // define data set
      const candleBaseUrl = 'https://finnhub.io/api/v1/stock/candle?symbol=';
      const secondsPer30Days = 30 * 24 * 60 * 60;
      const thirtyDaysAgo = now - secondsPer30Days;

      // allowable resolutions: 1, 5, 15, 30, 60, D, W, M - all strings, numbers represent minutes
      const resolution = '1';

      // two symbols to compare - program written specifically to compare GOOG and GOOGL
      const symbols = ['GOOG', 'GOOGL'];

      // empty array for results
      const results = {};

      // fetch the data from finnhub
      for (const symbol of symbols) {
        fetch(candleBaseUrl + symbol + '&resolution=' + resolution + '&from=' + thirtyDaysAgo + '&to=' + now + '&token=c6aifiiad3id24fn2m00')
        .then((response) => {
          return response.json();
        })
        .then((obj) => {
          // load the results array
          // console.log(obj);
          results[symbol] = obj;
          if (symbols[0] in results && symbols[1] in results) {
            // console.log(results);
            processData();
          }
        })
        .catch((error) => {
          console.error('Error fetching data: ', error);
        });
      }

      // Eliminate data elements from symbolA data that are not included
      // in symbolB data, and are outside of normal exchange hours.
      // This only works in the Pacific time zone because of the hours and
      // minutes specified in the culling filter.
      const cullSpurious = (symbolA, symbolB) => {
        for (let index = results[symbolA].t.length - 1; index > -1; index--) {
          const dateInSeconds = results[symbolA].t[index];
          const date = new Date(dateInSeconds * 1000);
          // culling filter
          if ((date.getHours() < 7 && date.getMinutes() < 31) ||
            date.getHours() < 6 ||
            (date.getHours() > 12 && date.getMinutes() > 0) ||
            !results[symbolB].t.includes(dateInSeconds) || 
            date.getDay() === 0 ||
            date.getDay() === 6) {
            for (elem in results[symbolA]) {
              if (typeof(results[symbolA][elem]) === 'object') {
                results[symbolA][elem].splice(index, 1);
              }
            }
          }
        }
      }

      // declare and initialize graphData object
      const graphData = {};
      graphData.timeStamp = [];
      graphData.lowDiff = [];
      graphData.highDiff = [];

      // declare range variables for Y axis
      let maxY = 0;
      let minY = 0;

      // Performs multiple processing steps to filter the data and load graphData object
      const processData = () => {
        cullSpurious(symbols[0], symbols[1]);
        cullSpurious(symbols[1], symbols[0]);

        // console.log(results);

        // combine month data into days
        let dayIndex = 0;
        let prevDayIndex = 0;
        let currentDay = new Date(results[symbols[0]].t[0] * 1000).getDay();

        const daysObj = {};
        daysObj.timeStamps = [];
        daysObj[symbols[0]] = [];
        daysObj[symbols[0]].high = [];
        daysObj[symbols[0]].low = [];
        daysObj[symbols[1]] = [];
        daysObj[symbols[1]].high = [];
        daysObj[symbols[1]].low = [];

        for (dateInSeconds of results[symbols[0]].t) {
          const day = new Date(dateInSeconds * 1000).getDay();
          if (day !== currentDay || dateInSeconds === results[symbols[0]].t.slice(-1)[0]) {
            daysObj.timeStamps.push(results[symbols[0]].t.slice(prevDayIndex, dayIndex));
            daysObj[symbols[0]].high.push(results[symbols[0]].h.slice(prevDayIndex, dayIndex));
            daysObj[symbols[0]].low.push(results[symbols[0]].l.slice(prevDayIndex, dayIndex));
            daysObj[symbols[1]].high.push(results[symbols[1]].h.slice(prevDayIndex, dayIndex));
            daysObj[symbols[1]].low.push(results[symbols[1]].l.slice(prevDayIndex, dayIndex));
            currentDay = day;
            prevDayIndex = dayIndex;
          }
          dayIndex++;
        }
        console.log(daysObj);

        // Load graphData object with data
        for (let index = 0; index < daysObj.timeStamps.length; index++) {
          if (index < daysObj.timeStamps.length - 1) {
            graphData.timeStamp[index] = daysObj.timeStamps[index][0];
            const highY = Math.max(...daysObj[symbols[0]].high[index].map((n, i) => n - daysObj[symbols[1]].low[index][i]));
            const lowY = Math.min(...daysObj[symbols[0]].low[index].map((n, i) => n - daysObj[symbols[1]].high[index][i]));
            maxY = highY > maxY ? highY : maxY;
            minY = lowY < minY ? lowY : minY;
            graphData.highDiff[index] = highY;
            graphData.lowDiff[index] = lowY;
          }
          // else if (daysObj.timeStamps[index] )
        }
        console.log(graphData);

        drawGraph();
      }
      
      const drawGraph = () => {
        const graph = document.getElementById('graph');
        graph.width = 500;
        graph.height = 500;
        const ctxGraph = graph.getContext('2d');
        const xPixelsPerDiv = 400 / graphData.timeStamp.length;
        let x = 50 + xPixelsPerDiv;
  
        const graphMinY = 10 * Math.floor(minY / 10);
        const graphMaxY = 10 * Math.ceil(maxY / 10);
        const graphRange = graphMaxY - graphMinY;
        const graphZeroRatio = graphMinY < 0 ? graphMaxY / graphRange : 1;
        const yPxPerDollar = 400 / graphRange;

        ctxGraph.beginPath();
        ctxGraph.moveTo(50, 450);
        ctxGraph.lineTo(50, 50);
        ctxGraph.moveTo(50, 50 + 400 * graphZeroRatio);
        ctxGraph.lineTo(450, 50 + 400 * graphZeroRatio);
        ctxGraph.stroke();
        const ticks = graphMaxY - graphMinY + 1;
        for (let tick = 0; tick < ticks; tick++) {
          if (tick % 10 === 0) {
            ctxGraph.moveTo(45, 50 + tick * yPxPerDollar);
            ctxGraph.lineTo(50, 50 + tick * yPxPerDollar);
            ctxGraph.stroke();
            ctxGraph.textBaseline = 'middle';
            ctxGraph.textAlign = 'right';
            ctxGraph.font = '15px sans-serif';
            ctxGraph.fillText('' + graphMaxY - tick, 40, 50 + tick * yPxPerDollar);
          }
        }

        for (let index = 0; index < graphData.timeStamp.length; index++) {
          ctxGraph.strokeStyle = 'blue';
          const yLow = 50 + (graphZeroRatio * graphRange - graphData.lowDiff[index]) * yPxPerDollar ;
          const yHigh = 50 + (graphZeroRatio * graphRange - graphData.highDiff[index]) * yPxPerDollar ;
          ctxGraph.beginPath();
          ctxGraph.moveTo(x, yLow);
          ctxGraph.lineTo(x, yHigh);
          ctxGraph.stroke();
          x += xPixelsPerDiv;
        }
      }
    </script>
  </body>
</html>
