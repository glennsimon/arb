<html>
  <head>
    <style>
      html {
        box-sizing: border-box;
      }
      
      *,
      *:before,
      *:after {
        box-sizing: inherit;
      }
      
      body {
        font-family: "Roboto", "Helvetica", "Arial", Sans-Serif;
        background-color: #f6f6f6;
        font-size: 16px;
        margin: 0;
      }
      
      .container {
        display: flex;
        flex-flow: row wrap;
        text-align: center;
      }

      .container > * {
        flex: 1 100%;
      }

      .row {
        flex: 1 0%;
      }

      .ticker {
        font-size: 6vh;
        height: 10vh;
        margin: auto;
      }

      .price {
        font-size: 5vh;
        height: 6vh;
      }

    </style>
  </head>
  <body>
    <div class='container'>
      <div class='row'>
        <div class='ticker'>GOOG</div>
        <div class='price' id='goog'></div>
      </div>
      <div class='row'>
        <div class='ticker'>GOOGL</div>
        <div class='price' id='googl'></div>
      </div>
      <div id='diff'></div>
      <div id='nytime'></div>
      <canvas id='graph'></canvas>
    </div>
    <script>
      const arb = () => {
        // two symbols to compare - program written specifically to compare GOOG and GOOGL
        const symbols = ['GOOG', 'GOOGL'];

        // declare array for last price of each stock, initialized at 0
        const lastValue = [0, 0];
  
        // declare object to contain results for fetched data
        let results = {};
    
        // get handles for document elements used for stock price updates
        const goog = document.getElementById('goog');
        const googl = document.getElementById('googl');
        const diff = document.getElementById('diff');
        const nYTime = document.getElementById('nytime');
    
        // Subscribe to web socket for real-time stock data
        // parameter is array of stock symbols, capitalized
        const ws = () => {
          // get handle for web socket - needed to subscribe to stock prices
          const socket = new WebSocket('wss://ws.finnhub.io?token=c6aifiiad3id24fn2m00');

          // set default values for document elements
          goog.innerText = 'No data yet';
          googl.innerText = 'No data yet';
          diff.innerText = 'Diff: No data yet';
          nYTime.innerText = `Time in NY: ${new Date().toLocaleString('en-US', {timeZone: 'America/New_York'})}`;
          
          // open an event listener on the web socket and subscribe to stock price updates
          socket.addEventListener('open', (event) => {
            socket.send(JSON.stringify({'type':'subscribe', 'symbol':symbols[0]}));
            socket.send(JSON.stringify({'type':'subscribe', 'symbol':symbols[1]}));
          });
    
          let minutes;

          // handle stock price update messages from the web socket.
          socket.addEventListener('message', (event) => {
            const parsedObj = JSON.parse(event.data);
            if (parsedObj.data) {
              let objMinutes;
              for (const obj of parsedObj.data) {
                const date = new Date(obj.t);
                objMinutes = date.getMinutes();
                if (obj.s === symbols[0]) {
                  goog.innerText = '' + (obj.p).toFixed(2);
                  lastValue[0] = obj.p;
                }
                if (obj.s === symbols[1]) {
                  googl.innerText = '' + (obj.p).toFixed(2);
                  lastValue[1] = obj.p;
                }
                diff.innerText = lastValue[0] === 0 ? 'N/A' :
                  `Diff: ${(lastValue[0] - lastValue[1]).toFixed(2)} (${(100 * (lastValue[0] - lastValue[1]) / lastValue[0]).toFixed(2)} %)`;
                nYTime.innerText = `NYC Time: ${date.toLocaleString('en-US', {timeZone: 'America/New_York'})}`;
                drawPoint();
              }
              if (minutes && minutes !== objMinutes) {
                results = {};
                fetchCandles();
              }
              minutes = objMinutes;
            } else {
              console.log('non-data object: ' + event.data);
            }
          });
    
          // helper function to unsubscribe if needed
          const unsubscribe = (symbol) => {
            socket.send(JSON.stringify({'type':'unsubscribe', 'symbol': symbol}));
          }
        }
  
        // fetch candle data for symbols
        const fetchCandles = () => {
          // get current date and time
          const now = Math.floor(Date.now() / 1000);
    
          // define data set
          const candleBaseUrl = 'https://finnhub.io/api/v1/stock/candle?symbol=';
          const secondsPer30Days = 30 * 24 * 60 * 60;
          const thirtyDaysAgo = now - secondsPer30Days;
    
          // allowable resolutions: 1, 5, 15, 30, 60, D, W, M - all strings, numbers represent minutes
          // this program will always use 1 minute interval
          const resolution = '1';
    
          // fetch the data from finnhub
          for (const symbol of symbols) {
            fetch(candleBaseUrl + symbol + '&resolution=' + resolution + '&from=' + thirtyDaysAgo + '&to=' + now + '&token=c6aifiiad3id24fn2m00')
            .then((response) => {
              return response.json();
            })
            .then((obj) => {
              // load the results array
              // console.log(obj);
              results[symbol] = obj;
              if (symbols[0] in results && symbols[1] in results) {
                processData();
              }
            })
            .catch((error) => {
              console.error('Error fetching data: ', error);
            });
          }
        }

  
        // Eliminate data elements from symbolA data that are not included
        // in symbolB data, and are outside of normal exchange hours.
        // This only works in the Pacific time zone because of the hours and
        // minutes specified in the culling filter.
        const cullSpurious = (symbolA, symbolB) => {
          for (let index = results[symbolA].t.length - 1; index > -1; index--) {
            const dateInSeconds = results[symbolA].t[index];
            const date = new Date(dateInSeconds * 1000);
            // culling filter
            if ((date.getHours() < 7 && date.getMinutes() < 31) ||
              date.getHours() < 6 ||
              (date.getHours() > 12 && date.getMinutes() > 0) ||
              !results[symbolB].t.includes(dateInSeconds) || 
              date.getDay() === 0 ||
              date.getDay() === 6) {
              for (elem in results[symbolA]) {
                if (typeof(results[symbolA][elem]) === 'object') {
                  results[symbolA][elem].splice(index, 1);
                }
              }
            }
          }
        }

        // Returns an array of indices in <results> spaced <minutes> apart
        const idxEngine = (minutes) => {
          const idxArray = [0];
          // const firstMinute = results[symbols[0]].t[0];
          const date = new Date(results[symbols[0]].t[0] * 1000);
          let prevDay = date.getDay();
          let prevHour = date.getHours();
          let prevMin = minutes * Math.floor(date.getMinutes() / minutes);
          let incr = 1;
          for (let idx = 0; idx < results[symbols[0]].t.length; idx++) {
            const nextDate = new Date(results[symbols[0]].t[idx] * 1000);
            let nextDay = nextDate.getDay();
            let nextHour = nextDate.getHours();
            let nextMin = nextDate.getMinutes();
            if (prevDay !== nextDay) {
              idxArray.push(idx);
              prevDay = nextDay;
              prevHour = nextHour;
              prevMin = minutes * Math.floor(nextMin / minutes);
            } else if (minutes <= 60 && prevHour != nextHour && nextHour !== 13) { // time zone dependent (hour 13)
              idxArray.push(idx + 1); // add 1 to include time until top of hour in data
              prevHour = nextHour;
              prevMin = minutes * Math.floor(nextMin / minutes);
            } else if (nextMin - prevMin > minutes) {
              idxArray.push(idx);
              prevMin = minutes * Math.floor(nextMin / minutes);
            }
          }
          return idxArray;
        }

        // load graphData with results data based on indicesArray elements and return new graphData object
        const loadGraphData = (startIndex, endIndex, indicesArray, timespan, graphData) => {
          // if empty, initialize graphData object
          if (! graphData.timeStamps) {
            graphData.maxY = 0;
            graphData.minY = 0;
            graphData.timeStamps = [];
            for (objName of ['days', 'qHours', 'minutes']) {
              graphData[objName] = {};
              graphData[objName].lowDiff = [];
              graphData[objName].highDiff = [];
              graphData[objName].openDiff = [];
              graphData[objName].closeDiff = [];
            }
          }
  
          // Load graphData with results data based on indicesArray
          for (let idx = startIndex; idx < endIndex; idx++) {
            // graphData.timeStamps.push(results[symbols[0]].t.slice(indicesArray[idx], indicesArray[idx + 1])[0]);
            graphData.timeStamps.push(results[symbols[0]].t[indicesArray[idx]]);
            const highY = Math.max(...results.highDiff.slice(indicesArray[idx], indicesArray[idx + 1]));
            const lowY = Math.min(...results.lowDiff.slice(indicesArray[idx], indicesArray[idx + 1]));
            const openY = results.openDiff[indicesArray[idx]];
            // closeIndex calc is to make sure the close is captured for the last minute of data
            const closeIndex =
              indicesArray[idx] === results[symbols[0]].t.length - 1 ?
              indicesArray[idx] : indicesArray[idx + 1] - 1;
            const closeY = results.closeDiff[closeIndex];
            graphData[timespan].highDiff.push(highY);
            graphData[timespan].lowDiff.push(lowY);
            graphData[timespan].openDiff.push(openY);
            graphData[timespan].closeDiff.push(closeY);
            graphData.maxY = highY > graphData.maxY ? highY : graphData.maxY;
            graphData.minY = lowY < graphData.minY ? lowY : graphData.minY;
          }
          return graphData;
        }

        // Performs multiple processing steps to filter the data and load graphData object
        const processData = () => {
          // get initial values for prices and differences or handle off hours
          handleAfterHours();

          // Eliminate spurious data
          cullSpurious(symbols[0], symbols[1]);
          cullSpurious(symbols[1], symbols[0]);
  
          // console.log(results);
  
          // Declare and load arrays for indices of first occurrance of day/hour in results
          const dayIndices = idxEngine(24 * 60);
          const qHourIndices = idxEngine(15);
  
          // get diff data for each data point
          results.highDiff = results[symbols[0]].h.map((n, i) =>
            n - results[symbols[1]].h[i] > results[symbols[0]].l[i] - results[symbols[1]].l[i] ?
            n - results[symbols[1]].h[i] : results[symbols[0]].l[i] - results[symbols[1]].l[i]
          );
          results.lowDiff = results[symbols[0]].l.map((n, i) =>
            n - results[symbols[1]].l[i] < results[symbols[0]].h[i] - results[symbols[1]].h[i] ?
            n - results[symbols[1]].l[i] : results[symbols[0]].h[i] - results[symbols[1]].h[i]
          );
          results.openDiff = results[symbols[0]].o.map((n, i) => n - results[symbols[1]].o[i]);  // subract low GOOG from low GOOGL
          results.closeDiff = results[symbols[0]].c.map((n, i) => n - results[symbols[1]].c[i]);  // subract low GOOG from low GOOGL
  
          // declare graphData object
          let graphData = {};

          // load graphData with days data
          graphData = loadGraphData(1, dayIndices.length - 1, dayIndices, 'days', graphData);

          // load graphData with qHours data
          let lastDayIndex = dayIndices[dayIndices.length - 1];
          let startIndex = qHourIndices.indexOf(lastDayIndex);
          graphData = loadGraphData(startIndex, qHourIndices.length - 1, qHourIndices, 'qHours', graphData);

          // load graphData with minutes data
          const resultsLength = results[symbols[0]].t.length;
          startIndex = resultsLength - 15;
          startIndex = startIndex > lastDayIndex ? startIndex : lastDayIndex; // should this be lastDayIndex + 1
          const minuteIndices = results[symbols[0]].t.slice(startIndex, resultsLength).map((n, i) => i + startIndex);
          loadGraphData(0, minuteIndices.length, minuteIndices, 'minutes', graphData);

          console.log(graphData);
          drawGraph(graphData);
          console.log('done');
        }
        
        // get the graph canvas and initialize its size
        const graph = document.getElementById('graph');
        graph.width = window.innerWidth;
        graph.height = 0.5 * window.innerHeight;
        const ctxGraph = graph.getContext('2d');
        const gParams = {};

        let leftMargin = 0.05 * graph.width;
        let topMargin = 0.05 * graph.height;
        let plotWidth = graph.width - 2 * leftMargin;
        let plotHeight = graph.height - 2 * topMargin;

        const drawGraph = (graphData) => {
          ctxGraph.clearRect(0, 0, graph.width, graph.height);
          const xPixelsPerDiv = plotWidth / (graphData.timeStamps.length + 1);
          let x = leftMargin + xPixelsPerDiv / 2;
          gParams.xPixelsPerDiv = xPixelsPerDiv;
          gParams.dataLength = graphData.timeStamps.length;
    
          const graphMinY = 10 * Math.floor(graphData.minY / 10);
          const graphMaxY = 10 * Math.ceil(graphData.maxY / 10);
          const graphRange = graphMaxY - graphMinY;
          gParams.graphRange = graphRange;
          const graphZeroRatio = graphMinY < 0 ? graphMaxY / graphRange : 1;
          const yPxPerDollar = plotHeight / graphRange;
          gParams.graphZeroRatio = graphZeroRatio;
          gParams.yPxPerDollar = yPxPerDollar;
  
          // Draw shading
          const daysWidth = graphData.days.highDiff.length * xPixelsPerDiv;
          const qHoursWidth = graphData.qHours.highDiff.length * xPixelsPerDiv;
          const minutesWidth = graphData.minutes.highDiff.length * xPixelsPerDiv;
          ctxGraph.fillStyle = 'rgba(0,0,0,0.4)';
          ctxGraph.fillRect(leftMargin, topMargin, daysWidth, plotHeight);
          ctxGraph.fillStyle = 'rgba(0,0,0,0.2)';
          ctxGraph.fillRect(leftMargin + daysWidth, topMargin, qHoursWidth, plotHeight);
          ctxGraph.fillStyle = 'rgba(0,0,0,0.1)';
          ctxGraph.fillRect(leftMargin + daysWidth + qHoursWidth, topMargin,
            minutesWidth + xPixelsPerDiv, plotHeight);
  
          // Draw axes and tick marks
          ctxGraph.fillStyle = 'black';
          ctxGraph.strokeStyle = 'black';
          ctxGraph.lineCap = 'square';
          ctxGraph.lineWidth = 1;
          ctxGraph.beginPath();
          ctxGraph.moveTo(leftMargin, topMargin + plotHeight);
          ctxGraph.lineTo(leftMargin, topMargin);
          ctxGraph.moveTo(leftMargin, topMargin + plotHeight * graphZeroRatio);
          ctxGraph.lineTo(leftMargin + plotWidth, topMargin + plotHeight * graphZeroRatio);
          ctxGraph.stroke();
          const ticks = graphMaxY - graphMinY + 1;
          for (let tick = 0; tick < ticks; tick++) {
            if (tick % 10 === 0) {
              ctxGraph.moveTo(0.9 * leftMargin, topMargin + tick * yPxPerDollar);
              ctxGraph.lineTo(leftMargin, topMargin + tick * yPxPerDollar);
              ctxGraph.stroke();
              ctxGraph.textBaseline = 'middle';
              ctxGraph.textAlign = 'right';
              ctxGraph.font = '' + 0.05 * plotHeight + 'px sans-serif';
              ctxGraph.fillText('' + graphMaxY - tick, 0.8 * leftMargin, topMargin + tick * yPxPerDollar);
            }
          }

          // Draw data values
          for (let index = 0; index < graphData.timeStamps.length; index++) {
            let graphSub = graphData.days;
            let subIndex = index;
            ctxGraph.strokeStyle = 'magenta';
            if (index >= graphData.timeStamps.length - graphData.minutes.highDiff.length) {
              graphSub = graphData.minutes;
              subIndex = index - (graphData.timeStamps.length - graphData.minutes.highDiff.length);
              ctxGraph.strokeStyle = 'red';
            } else if (index >= graphData.days.highDiff.length) {
              graphSub = graphData.qHours;
              subIndex = index - graphData.days.highDiff.length;
              ctxGraph.strokeStyle = 'blue';
            }
            const yLow = topMargin + (graphZeroRatio * graphRange - graphSub.lowDiff[subIndex]) * yPxPerDollar;
            const yHigh = topMargin + (graphZeroRatio * graphRange - graphSub.highDiff[subIndex]) * yPxPerDollar;
            const yOpen = topMargin + (graphZeroRatio * graphRange - graphSub.openDiff[subIndex]) * yPxPerDollar;
            const yClose = topMargin + (graphZeroRatio * graphRange - graphSub.closeDiff[subIndex]) * yPxPerDollar;
            ctxGraph.strokeStyle = yOpen >= yClose ? 'green' : 'red';
            ctxGraph.lineWidth = 2;
            ctxGraph.beginPath();
            ctxGraph.moveTo(x, yLow);
            ctxGraph.lineTo(x, yHigh);
            ctxGraph.stroke();
            ctxGraph.lineWidth = 6;
            ctxGraph.beginPath();
            ctxGraph.moveTo(x, yOpen);
            ctxGraph.lineTo(x, yClose);
            ctxGraph.stroke();
            x += xPixelsPerDiv;
          }
        }

        // Draws a point on the graph when the web socket gets a new value
        const drawPoint = () => {
          const instDiff = lastValue[0] !== 0 && lastValue[1] !== 0 ? lastValue[0] - lastValue[1] : null;
          if (instDiff) {
            ctxGraph.fillStyle = 'rgba(255,255,0,.2)';
            ctxGraph.beginPath();
            ctxGraph.arc(
              leftMargin + gParams.xPixelsPerDiv * (0.5 + gParams.dataLength),
              topMargin + (gParams.graphZeroRatio * gParams.graphRange - instDiff) * gParams.yPxPerDollar,
              3, 0, 2 * Math.PI
            );
            ctxGraph.fill();
          }
        }

        const handleAfterHours = () => {
          if (lastValue[0] === 0 && lastValue[1] === 0) {
            const googPrice = results[symbols[0]].c.at(-1);
            const googlPrice = results[symbols[1]].c.at(-1);
            goog.innerText = '' + (googPrice).toFixed(2);
            googl.innerText = '' + (googlPrice).toFixed(2);
            diff.innerText = `Diff: ${(googPrice - googlPrice).toFixed(2)} (${(100 * (googPrice - googlPrice) / googPrice).toFixed(2)} %)`;
          }
        }

        ws();
        fetchCandles();
      }
      arb();
    </script>
  </body>
</html>
